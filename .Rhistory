y_trans_1 <- sqrt(1-ro^2)*y_ar[1]
x_trans_1 <- sqrt(1-ro^2)*x_ar[1]
psi_trans_1 <-  sqrt(1-ro^2)
y_trans_2 <- y_ar[-1] - ro*y_ar[-n_sample]
x_trans_2 <- x_ar[-1] - ro*x_ar[-n_sample]
psi_trans_2 <- rep(1-ro, n_sample-1)
psi_trans_2
y_trans_all <- c(y_trans_1, y_trans_2)
x_trans_all <- c(x_trans_1, x_trans_2)
psi_trans_all <- c(psi_trans_1, psi_trans_2)
psi_trans_all
mod_gls_hand <- lm(y_trans_all ~ psi_trans_all + x_trans_all - 1)
summary(mod_gls_hand)
summary(mod_gls_hand)
d <- data.frame(
y_ar = y_ar,
x_ar = x_ar
)
mod_gls_PW <- prais_winsten(y_ar ~ x_ar, data=d, iter=1)
library(prais)
mod_gls_PW <- prais_winsten(y_ar ~ x_ar, data=d, iter=1)
library(xts)
library(forecast)
library(ggplot2)
library(ggfortify)
library(urca)
library(tseries)
set.seed(2)
n_sample <- 400
y_ar <- arima.sim(n=n_sample, model=list(order=c(1,0,0), ar=c(0.8)))
x_ar <- arima.sim(n=n_sample, model=list(order=c(1,0,0), ar=c(0.8)))
mod_ols_ar <- lm(y_ar ~ x_ar)
resid_ols_ar <- mod_ols_ar$residuals
#切片なし
mod_ols_resid <- lm(resid_ols_ar[-1] ~ resid_ols_ar[-n_sample] - 1)
ro <- as.numeric(mod_ols_resid$coefficients)
y_trans_1 <- sqrt(1-ro^2)*y_ar[1]
x_trans_1 <- sqrt(1-ro^2)*x_ar[1]
psi_trans_1 <-  sqrt(1-ro^2)
y_trans_2 <- y_ar[-1] - ro*y_ar[-n_sample]
x_trans_2 <- x_ar[-1] - ro*x_ar[-n_sample]
psi_trans_2 <- rep(1-ro, n_sample-1)
y_trans_all <- c(y_trans_1, y_trans_2)
x_trans_all <- c(x_trans_1, x_trans_2)
psi_trans_all <- c(psi_trans_1, psi_trans_2)
mod_gls_hand <- lm(y_trans_all ~ psi_trans_all + x_trans_all - 1)
d <- data.frame(
y_ar = y_ar,
x_ar = x_ar
)
library(prais)
mod_gls_PW <- prais_winsten(y_ar ~ x_ar, data=d, iter=1)
mod_gls_PW
mod_gls_PW <- prais_winsten(y_ar ~ x_ar, data=d, iter=1)
mod_gls_PW
summary(mod_gls_PW)
mod_gls_PW <- prais.winsten(y_ar ~ x_ar, data=d, iter=1)
library(prais)
mod_gls_PW <- prais.winsten(y_ar ~ x_ar, data=d, iter=1)
mod_gls_PW <- prais_winsten(y_ar ~ x_ar, data=d, iter=1)
resid(mod_gls_PW)
jarque.bera.test(resid(mod_gls_PW))
checkresiduals(mod_gls_PW)
mod_gls_PW
summary(mod_gls_PW)
checkresiduals(mod_gls_hand)
cumsum(rnorm(n_sample))
autoplot(cumsum(rnorm(n_sample)))
autoplot(xts(cumsum(rnorm(n_sample))))
autoplot(ts(cumsum(rnorm(n_sample))))
y_rw <- cumsum(rnorm(n_sample)
x_rw <- cumsum(rnorm(n_sample)
autoplot(ts(y_rw))
y_rw <- cumsum(rnorm(n_sample))
x_rw <- cumsum(rnorm(n_sample))
autoplot(ts(y_rw))
autoplot(ts(x_rw))
mod_lm_diff <- lm(diff(y_rw) ~ diff(x_rw))
summary(mod_lm_diff)
set.seed(10)
rw <- cumsum(rnorm(n_sample))
rw
x_co <- 0.6 * rw + rnorm(n_sample)
y_co <- 0.4 * rw + rnorm(n_sample)
autoplot(x_co)
autoplot(ts(x_co))
x_co <- 0.6 * rw + rnorm(n_sample)
autoplot(ts(y_co))
ur.df(y_co, type="none")
summary(ur.df(y_co, type="none"))
ur.df(y_co, type="none")
summary(ur.df(x_co, type="none"))
df <- data.frame(
y_co = y_co,
x_co = x_co,
z = x_co - (0.6/0.4) * y_co
)
ts_df <- ts(df)
ts_df
autoplot(ts_df)
autoplot(ts_df, faces=T)
#二変数の共和分
data_mat <- matrix(nrow = n_sample, ncol = 2)
data_mat
data_mat[, 1]
data_mat[, 1] <- y_co
data_mat[, 2] <- x_co
ca.po(data_mat, demean="none")
summary(ca.po(data_mat, demean="none"))
y_co_diff <- diff(y_co)
x_co_diff <- diff(x_co)
mod_lm_diff_co <- lm(y_co_diff ~ x_co_diff)
summary(mod_lm_diff_co)
rw <- cumsum(rnorm(n_sample))
x_co <- 0.6 * rw + rnorm(n_sample)
y_co <- 0.4 * rw + rnorm(n_sample)
df <- data.frame(
y_co = y_co,
x_co = x_co,
z = x_co - (0.6/0.4) * y_co
)
ts_df <- ts(df)
autoplot(ts_df, faces=T)
y_co_diff <- diff(y_co)
x_co_diff <- diff(x_co)
mod_lm_diff_co <- lm(y_co_diff ~ x_co_diff)
summary(mod_lm_diff_co)
autoplot(ts_df, facets=T)
df_diff <- data.frame(
y_co_diff = y_co_diff,
x_co_diff = x_co_diff
)
autoplot(ts(df_diff))
autoplot(ts(df_diff), facets=T)
summary(ca.po(data_mat, demean="none"))
library(prais)
summary(ca.po(data_mat, demean="none"))
library(urca)
summary(ca.po(data_mat, demean="none"))
y_co_diff <- diff(y_co)
x_co_diff <- diff(x_co)
mod_lm_diff_co <- lm(y_co_diff ~ x_co_diff)
summary(mod_lm_diff_co)
set.seed(10)
n_sample
set.seed(10)
rw <- cumsum(rnorm(n_sample))
x_co <- 0.6 * rw + rnorm(n_sample)
y_co <- 0.4 * rw + rnorm(n_sample)
summary(ur.df(y_co, type="none"))
summary(ur.df(x_co, type="none"))
#二変数の共和分
data_mat <- matrix(nrow = n_sample, ncol = 2)
data_mat
data_mat[, 1] <- y_co
data_mat[, 2] <- x_co
summary(ca.po(data_mat, demean="none"))
y_co_diff <- diff(y_co)
x_co_diff <- diff(x_co)
mod_lm_diff_co <- lm(y_co_diff ~ x_co_diff)
summary(mod_lm_diff_co)
library(urca)
library(fpp)
library(vars)
library(ggplot2)
library(ggfortify)
library(xts)
usconsumption
index(usconsumption)
us_con <- usconsumption
us_con.index %/% 1
us_con.index
us_con
index(us_con)
index(us_con) %/% 1
us_con[, 'year']
head(us_con)
us_con[, 'income']
us_con[, 'year'] <- index(us_con) %/% 1
class(index(us_con) %/% 1)
typeof(index(us_con) %/% 1)
attributes(index(us_con) %/% 1)
aggregate(usconsumption, nfrequency=4, FUN=avg)
aggregate(usconsumption, nfrequency=4, FUN=AVG)
aggregate(usconsumption, nfrequency=4, FUN=mean)
head(usconsumption)
aggregate(usconsumption, nfrequency=4, FUN=mean)
head(aggregate(usconsumption, nfrequency=12, FUN=mean))
head(aggregate(usconsumption, nfrequency=1, FUN=mean))
head(usconsumption)
iris
summary(iris)
summary(usconsumption)
aggregate(usconsumption, nfrequency=1, FUN=mean)
head(aggregate(usconsumption, nfrequency=1, FUN=summary))
aggregate(usconsumption, nfrequency=1, FUN=summary)
aggregate(usconsumption, nfrequency=1, FUN=sum)
summary(usconsumption)
library(psych)
describeBy(usconsumption)
install.packages("psych")
describeBy(usconsumption)
library(psych)
describeBy(usconsumption)
autoplot(usconsumption, facets = T)
summary(usconsumption)
autoplot(usconsumption, facets = T)
library(psych)
library(urca)
library(fpp)
library(vars)
library(ggplot2)
library(ggfortify)
library(xts)
autoplot(usconsumption, facets = T)
summary(ur.df(usconsumption[, "consumption"], type="dfift"))
summary(ur.df(usconsumption[, "consumption"], type="drift"))
summary(ur.df(usconsumption[, "income"], type="drift"))
ccf(
usconsumption[, "consumption"],
usconsumption[, "income"],
plot=F
)
#相互相関
autoplot(
ccf(
usconsumption[, "consumption"],
usconsumption[, "income"],
plot=F
)
)
select_result <- VARselect(usconsumption, lag.max=10, type="const")
select_result
select_result$selection
select_result$selection[1]
var_bestorder <- var(
y=usconsumption,
type="const",
p=select_result$selection[1]
)
select_result$selection[1]
var_bestorder <- VAR(
y=usconsumption,
type="const",
p=select_result$selection[1]
)
summary(var_bestorder)
predict(var_bestorder, n.ahead=4)
autoplot(predict(var_bestorder, n.ahead=8),
ts.colour=1,
predict.colour=1)
causality(var_bestorder, cause="income")
causality(var_bestorder, cause="consumption")
library(urca)
library(fpp)
library(vars)
library(ggplot2)
library(ggfortify)
library(xts)
causality(var_bestorder, cause="consumption")
irf_consumption <- irf(var_bestorder,
impulse = "consumption",
response = c("consumption", "income"),
n.ahead=12,
boot=T)
plot(irf_consumption)
plot(fevd(var_bestorder, n.ahead=12))
fevd(var_bestorder, n.ahead=12)
# GARCH -------------------------------------------------------------------
library(xts)
library(fGarch)
library(rugarch)
library(forecast)
library(tseries)
library(ggplot2)
library(ggfortify)
library(gridExtra)
install.packages("fGarch")
install.packages("rugarch")
install.packages("rugarch")
library(fGarch)
library(rugarch)
# GARCH -------------------------------------------------------------------
library(xts)
library(forecast)
library(tseries)
library(ggplot2)
library(ggfortify)
library(gridExtra)
library(fGarch); library(rugarch)
n_sample <- 1000
spec1 <- garchSpec(model = list(omega=0.001, alpha=0.4, beta=0.5, mu=0.1),
cond.dist="norm")
spec1
set.seed(1)
getwd()
sim_garch <- garchSim(spec1,
n=n_sample,
extended=T)
sim_garch
?sim_garch
??sim_garch
class(sim_garch)
attributes(sim_garch)
sim_garch <- ts(sim_garch)
class(sim_garch)
attributes(sim_garch)
autoplot(sim_garch[, -3], facets=T, ylab="")
p_acf <- autoplot(acf(sim_garch[, "garch"],
plot=F,
main="original"
))
p_acf <- autoplot(acf(sim_garch[, "garch"], plot=F),
main="original"
))
p_acf <- autoplot(acf(sim_garch[, "garch"], plot=F),
main="original"
)
p_acf
acf(sim_garch[, "garch"], plot=F)
p_acf_sq <- autoplot(acf(sim_garch[, "garch"]^2, plot=F),
main="square"
)
grid.arrange(p_acf, p_acf_sq, ncol=1)
mod_fGarch <- garchFit(formula=~garch(1, 1),
data=sim_garch[, "garch"],
include.mean=T,
trace=F)
mod_fGarch
coef(mod_fGarch)
# モデルの推定
mod_rugarch <- ugarchfit(
spec=spec_rugarch1, data = simgarch[, "garch", solver='hybrid']
)
# GARCH Model
spec_rugach1 <- ugarchspec(
variance.model=list(model="sGARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0, 0), include.mean=T),
distribution.model="norm")
# モデルの推定
mod_rugarch <- ugarchfit(
spec=spec_rugarch1, data = simgarch[, "garch", solver='hybrid']
)
# GARCH Model
spec_rugarch1 <- ugarchspec(
variance.model=list(model="sGARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0, 0), include.mean=T),
distribution.model="norm")
# モデルの推定
mod_rugarch <- ugarchfit(
spec=spec_rugarch1, data = simgarch[, "garch", solver='hybrid']
)
# モデルの推定
mod_rugarch <- ugarchfit(
spec=spec_rugarch1, data = sim_garch[, "garch", solver='hybrid']
)
# モデルの推定
mod_rugarch <- ugarchfit(
spec=spec_rugarch1, data = sim_garch[, "garch", solver="hybrid"]
)
spec=spec_rugarch1, data = sim_garch[, "garch", solver="hybrid"
# モデルの推定
mod_rugarch <- ugarchfit(
spec=spec_rugarch1, data = sim_garch[, "garch"], solver="hybrid"
)
coef(mod_rugarch)
# GARCH -------------------------------------------------------------------
library(xts)
library(forecast)
library(tseries)
library(ggplot2)
library(ggfortify)
library(gridExtra)
install.packages("fGarch")
install.packages("fGarch")
install.packages("fGarch")
library(fGarch); library(rugarch)
n_sample <- 1000
# GARCH Model
spec1 <- garchSpec(model = list(omega=0.001, alpha=0.4, beta=0.5, mu=0.1),
cond.dist="norm")
sim_garch <- garchSim(spec1,
n=n_sample,
extended=T)
install.packages("fGarch")
install.packages("fGarch")
library(fGarch); library(rugarch)
install.packages("fGarch")
install.packages("fGarch")
library(fGarch); library(rugarch)
# GARCH Model
spec1 <- garchSpec(model = list(omega=0.001, alpha=0.4, beta=0.5, mu=0.1),
cond.dist="norm")
set.seed(1)
sim_garch <- garchSim(spec1,
n=n_sample,
extended=T)
class(sim_garch)
sim_garch <- ts(sim_garch)
class(sim_garch)
# ARMA+GARCH Model
spec2 <- garchSpec(model = list(omega=0.001, alpha=0.4, beta=0.5, mu=0.1, ar=-0.6, ma=-0.5),
cond.dist="norm")
set.seed(0)
sim_arma_garch <- garchSim(spec2,
n=n_sample,
extended=T)
sim_arma_garch <- garchSim(spec2,
n=n_sample,
extended=F)
# ARMA
mod_arma <- Arima(sim_arma_garch, order=c(1,0,1))
library(forecast)
# ARMA
mod_arma <- Arima(sim_arma_garch, order=c(1,0,1))
checkresiduals(mod_arma)
n_sample
# ARMA+GARCH Model データ生成
spec2 <- garchSpec(model = list(omega=0.001, alpha=0.4, beta=0.5, mu=0.1, ar=-0.6, ma=-0.5),
cond.dist="norm")
set.seed(0)
sim_arma_garch <- garchSim(spec2,
n=n_sample,
extended=F)
# ARMA
mod_arma <- Arima(sim_arma_garch, order=c(1,0,1))
checkresiduals(mod_arma)
checkresiduals(mod_arma)
library(xts)
library(forecast)
library(tseries)
library(ggplot2)
library(ggfortify)
library(gridExtra)
library(fGarch); library(rugarch)
checkresiduals(mod_arma)
dwtest(mod_arma)
library(lmtest)
dwtest(mod_arma)
sim_arma_garch
dwtest(mod_arma)
mod_arma
attributes(mod_arma)
?dwtest
dwtest(mod_arma$resuduals)
jarque.bera.test(mod_arma$resuduals)
mod_arma$resuduals
mod_arma
mod_arma$reisuduals
mod_arma$residuals
mod_arma$residuals
jarque.bera.test(mod_arma$residuals)
dwtest(mod_arma$residuals)
spec_rugarch2 <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(1, 1), include.mean=T),
distribution.model="norm")
mod_arma_garch <- ugarchfit(
spec=spec_rugarch2, data=sim_arma_garch, solver="hybrid")
coef(mod_arma_garch)
resid_arma_garch <- residuals(mod_arma_garch) / sigma(mod_arma_garch)
resid_arma <- mod_arma$residuals / sqrt(mod_arma$sigma2)
mod_arma_garch
d <- data.frame(arma_garch=resid_arma_garch,
arma=resid_arma)
autoplot(ts(d), facets=T, ylab="", main="normalized residuals")
#ネットワークの属性としてGroupeを追加
MPnet %v% "Party" <- as.character(party)
setwd("C:/Users/mas/learning/Network-Analysis-R")
getwd()
library(GGally)
library(network)
ggnet(MPnet, color="Party", palette="Set2",
alpha=0.75, size=4, edge.alpha=0.5)
URL <- "https://raw.githubusercontent.com/briatte/ggnet/master/inst/extdata/"
nodeURL <- paste(URL, "nodes.tsv", sep="")
edgeURL <- paste(URL, "network.tsv", sep="")
#
nodes <- read.csv(nodeURL, sep="\t")
edges <- read.csv(edgeURL, sep="\t")
MPnet <- network(edges, directed=T)
#頂点の名前リストをDataFrameに変換、339
party <- data.frame(Twitter=network.vertex.names(MPnet))
#頂点のnodesを抽出し、Groupeを選択
party <- merge(party, nodes, by="Twitter", sort=F)$Groupe
#ネットワークの属性としてGroupeを追加
MPnet %v% "Party" <- as.character(party)
MPnet
ggnet2(MPnet, color="Party", palette="Set2",
alpha=0.75, size=4, edge.alpha=0.5)
#地図との組み合わせ
install.packages("maps")
install.packages("geoshpere")
library(sna)
library(network)
library(sna)
library(maps)
library(ggplot2)
library(GGally)
URL <- "https://www.geocities.jp/snatool/sampledata/"
airports <- read.csv(paste(URL, "airport.csv", sep="\t"), header=T)
URL <- "http://www.geocities.jp/snatool/sampledata/"
airports <- read.csv(paste(URL, "airport.csv", sep="\t"), header=T)
URL <- "http://snatool.g2.xrea.com/sampledata/
変更前 > install_github('arcdiagram', username='gastonstat')
変更後 > install_github("gastonstat/arcdiagram")
airports <- read.csv(paste(URL, "airport.csv", sep="\t"), header=T)
URL <- "http://snatool.g2.xrea.com/sampledata/
URL <- "http://snatool.g2.xrea.com/sampledata/"
airports <- read.csv(paste(URL, "airport.csv", sep="\t"), header=T)
rownames(airports) <- airports$airport
airports$airport
airports
